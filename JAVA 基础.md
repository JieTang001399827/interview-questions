# JAVA 基础
## 1. JAVA异常分类及处理
### 1.1 概念
如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。

### 1.2 异常分类
Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception

- Error:  Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。

- Exception:  Exception 又有两个分支，一个是运行时异常 RuntimeException，一个是
 CheckedException。

 1. RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。( NullPointerException、 ClassCastException)。
 2. CheckedException:一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch。（如 I/O 错误导致的 IOException、SQLException）

### 1.3 异常的处理方式
遇到问题不进行具体处理，而是继续抛给调用者 (throw,throws)

抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。

### 1.4 throw 和 throws 的区别:
- 位置不同:  throws 用在函数上，后面跟的是异常类，可以跟多个;而 throw 用在函数内，后面跟的是异常对象。
- 功能不同： 

1. throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式;throw 抛出具体的问题对象，执行到 throw，功能就已经结束了。
2. throws 表示出现异常的一种可能性，并不一定会发生这些异常;throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。
3. 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。


## 2. JAVA反射
### 2.1 动态语言
动态语言，是指程序在运行时可以改变其结构:新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++ 则不属于动态语言。从反射角度说 JAVA 属于半动态语言。

### 2.2 反射机制概念 (运行状态中知道类所有的属性和方法)
 在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法;这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。

### 2.3 反射的应用场合（待）

### 2.4 Java 反射 API
反射 API 用来生成 JVM 中的类、接口或对象的信息。

1. Class 类:反射的核心类，可以获取类的属性，方法等信息。
2. Field 类:Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性
值。
3. Method 类: Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或
者执行方法。
4. Constructor 类: Java.lang.reflec 包中的类，表示类的构造方法。

### 2.5 反射使用步骤(获取 Class 对象、调用对象方法)
1. 获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方
 法。
2. 调用 Class 类中的方法，既就是反射的使用阶段。
3. 使用反射 API 来操作这些信息。

### 2.6 获取 Class 对象的 3 种方法
1. 调用某个对象的 getClass()方法
```java
Person p=new Person();
Class clazz=p.getClass();
```
2. 调用某个类的 class 属性来获取该类对应的 Class 对象
```java
Class clazz=Person.class;
```
3. 使用 Class 类中的 forName()静态方法(最安全/性能最好)
```java
Class clazz=Class.forName("类的全路径"); (最常用)
```

**当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法
和属性。**

```java
//获取 Person 类的 Class 对象
Class clazz=Class.forName("reflection.Person");

//获取 Person 类的所有方法信息
Method[] method=clazz.getDeclaredMethods(); for(Method m:method){
System.out.println(m.toString()); }
//获取 Person 类的所有成员属性信息
Field[] field=clazz.getDeclaredFields(); for(Field f:field){
System.out.println(f.toString()); }
//获取 Person 类的所有构造方法信息
Constructor[] constructor=clazz.getDeclaredConstructors(); for(Constructor c:constructor){
System.out.println(c.toString());
}
```

### 2.7 创建对象的两种方法
***Class 对象的 newInstance()***

1. 使用 Class 对象的newInstance()方法来创建该 Class对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。

***调用 Constructor 对象的 newInstance()***

2. 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。

```java
//获取 Person 类的 Class 对象
Class clazz=Class.forName("reflection.Person"); //使用.newInstane 方法创建对象
Person p=(Person) clazz.newInstance();
//获取构造方法并创建对象
Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);
//创建对象并设置属性
 Person p1=(Person) c.newInstance("李四","男",20);
```

# 3. JAVA注解
Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息。

### 3.1 4 种标准元注解
元注解的作用是负责注解其他注解。它们被用来提供对其它 annotation 类型作说明。

- @Target 修饰的对象范围
- @Retention 定义 被保留的时间长短
- @Documented 描述-javadoc
- @Inherited 阐述了某个被标注的类型是被继承的

### 3.2 注解处理器
用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。

# 4. JAVA内部类
定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。

### 4.1 静态内部类
定义在类内部的静态类，就是静态内部类。

- 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。
- 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。
- 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示:Out.Inner inner=new Out.Inner();inner.print();
- Java 集合类 HashMap 内部就有一个静态内部类 Entry。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。

### 4.2 成员内部类
定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量(final 修饰的除外)。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。

### 4.3 局部内部类(定义在方法中的类)
定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。

### 4.4 匿名内部类(要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用)
匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。

# 5. JAVA泛型
泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。

### 5.1 泛型方法(<E>)
你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。
1. <? extends T>表示该通配符所代表的类型是 T 类型的子类。
2. <? super T>表示该通配符所代表的类型是 T 类型的父类。

### 5.2 泛型类<T>
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。

### 5.3 类型通配符?
类型通配符一般是使用?代替具体的类型参数。例如 List<?> 在逻辑上是 List<String>,List<Integer> 等所有 List<具体类型实参>的父类。

### 5.4 类型擦除
Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。


# 6. JAVA序列化(创建可复用的Java对象)
- 保存(持久化)对象及其状态到内存或者磁盘:

Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。

- 序列化对象以字节数组保存-静态成员不保存

在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。

- 序列化用户远程对象传输

除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该 API 简单易用。

**Serializable 实现序列化**
在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。

# 7. JAVA复制
将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。

### 7.1 直接赋值复制
在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。

### 7.2 浅复制(复制引用但不复制引用的对象)
创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制;如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。

### 7.3 深复制(复制对象和其应用对象)
深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。

### 7.4 序列化(深 clone 一中实现)
在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象(实际上只是对象的一个拷贝)写到一个流里，再从流里读出来，便可以重建对象。













