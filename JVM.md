# JVM

### 基本概念
JVM是可运行Java代码的假想计算机，包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收站，堆和一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。

### 运行过程
Java源文件通过编译器，生产相应的.class字节码文件，字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码。

**Java为什么能够跨平台：JVM来向下关联所有操作系统，他能操作所有操作系统，向上提供统一接口，也就是JavaAPI，程序员只要面向JVM编程，将想要让操作系统做的告诉JVM，它就会去跟操作系统转达**

# 2.1 线程
当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好之后，就会创建一个操作系统原生线程。Java线程结束，原生线程随之被回收。操作系统负责调度所有的线程，并把他们分配到任何可用的CPU上。当原生线程初始化完毕，就会调用Java线程的run()方法。当线程结束时，会释放原生线程和java线程的所有线程。

# 2.2 JVM内存区域
JVM内存区域主要分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（JAVA堆，方法区）、直接内存。
+ 线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁。（每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/ 否跟随本地线程的生/死对应）
+ 线程共享区域随虚拟机的启动/关闭而创建/销毁。
+ 直接内存并不是JVM运行时数据区的一部分，它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

### 2.2.1 程序计数器（线程私有）
一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。

### 2.2.2 虚拟机栈（线程私有）
是描述 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
栈帧随着方法调用而创建，随着方法结束而销毁--无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

### 2.2.3 本地方法区（线程私有）
本地方法区和虚拟机栈类似，虚拟机栈为执行java方法服务，而本地方法栈则为Native方法服务。

### 2.2.4 堆（线程共享）-运行时数据区
是被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集最重要的内存区域。

### 2.2.5 方法区/永久代（线程共享）
永久代用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。使用Java堆的永久代来实现方法区，使垃圾收集器可以像管理Java堆一样管理这部分内存，而不必为方法区开发专门的内存管理器（永久代的内存回收主要目标是*针对常量池的回收*和*类型的卸载*）
运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。

# 2.3 JVM运行时内存
java堆可以细分为：新生代和老年代

### 2.3.1 新生代
用来存放新生的对象，一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区、ServivorFrom、ServivorTo三个区。
+ Eden区
java新对象的出生地（如果创建的对象占用内存很大，直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。
+ ServivorFrom
上一次GC的幸存者，作为这一次GC的被扫描者
+ ServivorTo
保留了一次MinorGC过程中的幸存者。

***MinorGC的过程（复制，清空，互换）***
**1:eden、servicorFrom 复制到 ServicorTo，年龄+1**
首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域(如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区)，同时把这些对象的年龄+1(如果 ServicorTo 不 够位置了就放到老年区);
**2:清空 eden、servicorFrom**
然后，清空 Eden 和 ServicorFrom 中的对象;
**3:ServicorTo 和 ServicorFrom 互换**
最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom
区。

### 2.3.2 老年代
主要存放应用程序中生命周期长的内存对象
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。
+ ***MajorGC 采用标记清除算法:***
首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出 OOM(Out of Memory)异常。

### 2.3.3 永久代
指内存的永久保存区域，主要存放Class和Meta（元数据）的信息，Class在被加载时被放入永久区域，它和存放实例的区域不同，GC不会在主程序运行期间对永久区域进行清理，这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。
（Java8中，永久代已经被移除，被一个称为元数据区的区域取代。元空间的本质和永久代类似，最大区别在于：**元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制**）

# 2.4 垃圾回收与算法

## 2.4.1 如何确定垃圾
### 2.4.1.1 引用计数法
在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。
### 2.4.1.2 可达性分析
为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

## 2.4.2 标记清除算法
最基础的垃圾回收算法，分为两个阶段：标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。
**该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题**

## 2.4.3 复制算法
为了解决标记清除算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
**这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，copying算法效率会大大降低**

## 2.4.4 标记整理算法
结合了以上两个算法，为了避免缺陷而提出。标记阶段和标记清除算法相同，标记后不是清理对象，而是将存活对象移向内存的额另一端。然后清除端边界外的对象。

## 2.4.5 分代收集算法
分代收集算法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域。一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

### 2.4.5.1 新生代和复制算法
目前大部分JVM的GC对于新生代都采用Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

### 2.4.5.2 老年代与标记复制算法
因为老年代每次只回收少量对象，因此采用mark-compact算法。
（当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中。）

# 2.5 java中的四种引用类型
## 2.5.1 强引用
在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成java内存泄漏的主要原因之一。
## 2.5.2 软引用 
软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它
不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
## 2.5.3 弱引用
弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象
来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
## 2.5.4 虚引用
 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

# 2.6 GC分代收集算法 VS分区收集算法
## 2.6.1 分代收集算法
这种算法会根据 对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的 GC 算法
## 2.6.2 分区收集算法
将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。好处是可以控制一次回收多少个小空间，根据目标停顿时间，每次合理地回收若干个小区间（而不是整个堆），从而减少一次GC所产生的的停顿。

# 2.7 GC垃圾收集器（未复习）

# 2.8 JAVA IO/NIO
## 2.8.1 阻塞 IO 模型
最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为:
```java
data = socket.read();
```
如果数据没有就绪，就会一直阻塞在 read 方法。
## 2.8.2 非阻塞IO模型
当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下:
```java
while(true){
    data = socket.read(); if(data!= error){ 处理数据
    break;
    }
}
```
但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。

## 2.8.3 多路复用IO模型
在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真 正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。
**（另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态
时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。）**
*不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件 逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件 迟迟得不到处理，并且会影响新的事件轮询。*

## 2.8.4 信号驱动IO模型
当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。

## 2.8.5 异步IO模型
异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。
+ **和信号驱动模型区别：**
在信号驱动模型中，当用户线程接收到信号表示数据 已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作;而在异步 IO 模型中，收到信号 表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。

（！异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。）

## 2.8.6 java IO
## 2.8.7 java NIO
NIO 主要有三大核心部分:Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字 符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件(比如:连接打开， 数据到达)。因此，单个线程可以监听多个数据通道。
**（NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。）**
### 2.8.7.1 NIO的缓冲区
Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在 缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所 有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的 数据。

### 2.8.7.2 NIO 的非阻塞
IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有 一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可 用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以 继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它 完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道(channel)。

### 2.8.7.3 Channel
Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如:InputStream, OutputStream，而Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。 NIO 中的 Channel 的主要实现有:

1. FileChannel

2. DatagramChannel

3. SocketChannel

4. ServerSocketChannel

分别可以对应文件 IO、UDP 和 TCP(Server 和 Client)。

### 2.8.7.4 Buffer
缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。

client->buffer->channel<->channel->buffer->server

客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必 须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。

在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有: ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer

### 2.8.7.5 Selector
Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。

# 2.9 JVM类加载机制
JVM 类加载机制分为五个部分:加载，验证，准备，解析，初始化。
## 2.9.1 加载
加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对
象，作为方法区这个类的各种数据的入口。
## 2.9.2 验证
 这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并 且不会危害虚拟机自身的安全。
## 2.9.3 准备
准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使 用的内存空间。
这里所说的初始值概念，比如一个类变量定义为:
```java
public static int v = 8080;
```
实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是
程序被编译后，存放于类构造器<client>方法之中。

但是注意如果声明为:
```java
public static final int v = 8080;
```
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v
赋值为 8080。

## 2.9.4 解析
 解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。
+ 符号引用
+ 直接引用

## 2.9.5 初始化
 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
+ 类构造器<client>：初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变 量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类 的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成<client>()方法。

## 2.9.6 类加载器
### 2.9.6.1 启动类加载器(Bootstrap ClassLoader)
负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被
虚拟机认可(按文件名识别，如 rt.jar)的类。
### 2.9.6.2 扩展类加载器(Extension ClassLoader)
负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。
### 2.9.6.3 应用程序类加载器(Application ClassLoader):
负责加载用户路径(classpath)上的类库。

**（JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader
实现自定义的类加载器。）**

## 2.9.7 双亲委派
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的
Class)，子类加载器才会尝试自己去加载。

 采用双亲委派的一个**好处**是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
 器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
 器最终得到的都是同样一个 Object 对象。

+ *自定义类加载器->应用程序类加载器->扩展类加载器->启动类加载器*









